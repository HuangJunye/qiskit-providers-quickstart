{
  "id": "runtimes",
  "title": "Quantum Runtimes",
  "description": "Cloud services that allow quantum-classical hybrid computations. Sometimes called near-team computing, this computation model allows relative quick iteration between classical and quantum processors, which is useful for variational algorithms.",
  "providers": [
    {
      "title": "IBM Qiskit Runtime",
      "image": "/images/providers/qiskit-ibm-runtime.png",
      "description": "Qiskit Runtime is a quantum computing service and programming model that allows users to optimize workloads and efficiently execute them on quantum systems at scale. The programming model extends the existing interface in Qiskit with a set of new primitive programs.",
      "installation": "pip install qiskit-ibm-runtime",
      "websiteCta": {
        "label": "Website",
        "url": "https://quantum-computing.ibm.com/lab/docs/iql/runtime/"
      },
      "docsCta": {
        "label": "Docs",
        "url": "https://qiskit.org/documentation/partners/qiskit_ibm_runtime/"
      },
      "sourceCta": {
        "label": "GitHub",
        "url": "https://github.com/Qiskit/qiskit-ibm-runtime"
      },
      "codeExamples": [
        {
          "name": "Bell state",
          "runMethod": "sampler",
          "fullCode": [
            "from qiskit_ibm_runtime import QiskitRuntimeService, Sampler",
            "service = QiskitRuntimeService()",
            "backend = service.backend(\"ibmq_qasm_simulator\")",
            "sampler = Sampler(session=backend)",
            "&nbsp;",
            "# Build circuit",
            "from qiskit import QuantumCircuit",
            "circuit = QuantumCircuit(2, 2)",
            "circuit.h(0)",
            "circuit.cx(0,1)",
            "circuit.measure([0,1], [0,1])",
            "&nbsp;",
            "# Run the circuit and get result distribution",
            "job = sampler.run(circuit)",
            "quasi_dist = job.result().quasi_dists[0]",
            "print(quasi_dist)"
          ]
        }
      ]
    }
  ]
}